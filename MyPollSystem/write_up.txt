Preview video for this project:
https://drive.google.com/file/d/1cfa-OmysUYosPPy98_Le4j8eQAN-HoDK/view?usp=sharing

For this project, each process is given quite clearly. First, read the data, secondly, separate them into multiple parts, then sort them individually and feed them to the merger via a pipe, finally merge all elements and output an ordered list. There are some places that I think particularly worth introducing.
At the very beginning, I decided to use linked list as the data structure for storage. My original intention is, comparing to plain array, linked list has a speed efficiency faced with merge sort. Hence I built everything on the footstone of linked list, never seeing that this little "shrewdness" would be an oversight very soon. Then when I do the two sorting algorithms, I have to choose are bubble sort and selection sort, two of the most brutal sorting algorithms.
Why? We all know that quick sort need a pivot and in array, get the pivot value needs O(1); but in a linked list, to get a element in the middle, you would need O(N), which would drag the sorting to a speed of at least O(N^2 logN), even slower than brutal sorting mentioned above with time complexity of O(N). And for another efficient sorting algorithm, heap sort, it's also harder for one-way linked list to insert nodes into the heap than array (from the perspective of me, a C rookie, and comments on how to achieve that easily are highly welcomed and appreciated). After the agonizing decision, I chose two most brutal sorting.
That actually quite inspire me: I only consider a pittance of efficiency at first, and didn't do a long-term planning, which leads to this dilemma. In later projects construction, I should really learn to think from a wider angle and to a deeper extent.
Another thing I especially would like to mentioned is the wait(). In the original version I used wait() to judge if all the child processes are over. It worked fine for data of size 1000 & 10000. But when it comes to 100000, problems appeared. It seems to be trapped in a dead loop where no wait() is called nor received, while reading just can't continue. After asking friends about that, I tried to use FIFO with O_NONBLOCK argument to avoid pipe blocked. To my surprise, it just didn't work when it should be. That's one of my biggest question during the construciton.
My resolution to that is to sleep, for an estimated length time which is dertermined after calculation. First part is the length of all sorting's running, then is the switching time among child process, finally is a const time which would be helpful when the data size is too small. I think it's kind of like a speculating, but it indeed works. Of course I would die for knowing how it could be done simply use wait() or FIFO setting.
Finally, I can tell you that all flag options are well polished. You can use them freely.
